<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>WebRTC Video Call</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin-top: 20px;
        background-color: #f4f4f4;
        color: #333;
      }
      h2 {
        color: #007bff;
      }
      button {
        padding: 10px 15px;
        margin: 5px;
        border: none;
        border-radius: 5px;
        background-color: #007bff;
        color: white;
        cursor: pointer;
        font-size: 16px;
      }
      button:hover {
        background-color: #0056b3;
      }
      input {
        padding: 8px;
        margin: 5px;
        border: 1px solid #ccc;
        border-radius: 4px;
        font-size: 16px;
      }
      video {
        width: 48%;
        height: auto;
        max-width: 640px;
        border: 2px solid #007bff;
        background-color: #333;
        margin: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        border-radius: 8px;
      }
      #localVideo {
        transform: scaleX(-1);
      }
      #statusMessage {
        margin-top: 15px;
        font-size: 1.1em;
        color: #555;
      }
    </style>
  </head>
  <body>
    <h2>WebRTC Video Call (ID: <span id="myId">?</span>)</h2>
    <div>
      <div>
        <input id="peerIdInput" placeholder="ID —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞" />
      </div>
      <div>
        <button onclick="startCall()">–ù–∞—á–∞—Ç—å –∑–≤–æ–Ω–æ–∫</button>
      </div>
      <div>
        <button onclick="hangUp()">–ó–∞–≤–µ—Ä—à–∏—Ç—å</button>
      </div>
    </div>
    
    <div>
      <button onclick="getLink()">–ü–æ–ª—É—á–∏—Ç—å —Å—Å—ã–ª–∫—É-–ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ</button>
    </div>

    <div id="statusMessage">–û–∂–∏–¥–∞–Ω–∏–µ...</div>

    <div
      style="
        margin-top: 20px;
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
      "
    >
      <video id="localVideo" autoplay muted playsinline></video>
      <video id="remoteVideo" autoplay playsinline></video>
    </div>

    <script>
      const socket = io();

      let myId = null;
      let currentPeerId = null;
      let pc = null;
      let localStream = null;

      const localVideo = document.getElementById("localVideo");
      const remoteVideo = document.getElementById("remoteVideo");
      const myIdEl = document.getElementById("myId");
      const peerIdInput = document.getElementById("peerIdInput");
      const statusMessageEl = document.getElementById("statusMessage");
      // –£–¥–∞–ª—è–µ–º telegramStatusEl
      // const telegramStatusEl = document.getElementById("telegramStatus");

      function updateStatus(message, isError = false) {
        statusMessageEl.textContent = message;
        statusMessageEl.style.color = isError ? "red" : "#555";
      }

      function resetCallState() {
        if (pc) {
          pc.close();
          pc = null;
          updateStatus("–ó–≤–æ–Ω–æ–∫ –∑–∞–≤–µ—Ä—à–µ–Ω. –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –æ—á–∏—â–µ–Ω–æ.");
        }
        if (localStream) {
          localStream.getTracks().forEach((track) => track.stop());
          localStream = null;
        }
        localVideo.srcObject = null;
        remoteVideo.srcObject = null;
        currentPeerId = null;
        peerIdInput.value = "";
      }

      async function getLocalStream() {
        if (localStream) return localStream;
        try {
          updateStatus("–ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ –∏ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É...");
          const stream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true,
          });
          localVideo.srcObject = stream;
          localStream = stream;
          updateStatus("–î–æ—Å—Ç—É–ø –ø–æ–ª—É—á–µ–Ω. –ú–æ—è –∫–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞.");
          return stream;
        } catch (e) {
          console.error("–ö–∞–º–µ—Ä–∞/–º–∏–∫—Ä–æ—Ñ–æ–Ω –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã", e);
          updateStatus(
            "‚ùå –ö–∞–º–µ—Ä–∞/–º–∏–∫—Ä–æ—Ñ–æ–Ω –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã. –†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø!",
            true
          );
          alert("–†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ –∏ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É!");
          return null;
        }
      }

      function createPeerConnection() {
        if (pc) {
          console.log(
            "–ó–∞–∫—Ä—ã–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–µ–µ PeerConnection –ø–µ—Ä–µ–¥ —Å–æ–∑–¥–∞–Ω–∏–µ–º –Ω–æ–≤–æ–≥–æ."
          );
          pc.close();
        }

        pc = new RTCPeerConnection({
          iceServers: [
            { urls: "stun:stun.l.google.com:19302" },
            { urls: "stun:stun1.l.google.com:19302" },
            {
              urls: "turn:217.154.5.134:3478",
              username: "webrtc",
              credential: "SuperSecurePass123",
            },
            {
              urls: "turn:217.154.5.134:3478?transport=tcp",
              username: "webrtc",
              credential: "SuperSecurePass123",
            },
            /* –ï—Å–ª–∏ TURN –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç TLS –Ω–∞ 443
            {
              urls: "turns:your.turn.server.com:443?transport=tcp",
              username: "webrtc",
              credential: "SuperSecurePass123",
            },
            */
          ],
        });

        pc.onicecandidate = (event) => {
          if (event.candidate) {
            console.log(
              ">>> –õ–û–ö–ê–õ–¨–ù–´–ô ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç:",
              event.candidate.candidate
            );
            if (currentPeerId) {
              socket.emit("message", {
                to: currentPeerId,
                type: "ice-candidate",
                candidate: event.candidate,
              });
            }
          } else {
            console.log(">>> –ì–µ–Ω–µ—Ä–∞—Ü–∏—è ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–∞");
          }
        };

        pc.ontrack = (event) => {
          console.log("–ü–æ–ª—É—á–µ–Ω —É–¥–∞–ª–µ–Ω–Ω—ã–π —Ç—Ä–µ–∫:", event.track, event.streams);
          if (
            event.streams &&
            event.streams[0] &&
            remoteVideo.srcObject !== event.streams[0]
          ) {
            remoteVideo.srcObject = event.streams[0];
            updateStatus("–£–¥–∞–ª–µ–Ω–Ω—ã–π –≤–∏–¥–µ–æ–ø–æ—Ç–æ–∫ –ø–æ–ª—É—á–µ–Ω!");
          }
        };

        pc.onconnectionstatechange = () => {
          console.log("–°–æ—Å—Ç–æ—è–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è WebRTC:", pc.connectionState);
          updateStatus(`–°–æ—Å—Ç–æ—è–Ω–∏–µ –∑–≤–æ–Ω–∫–∞: ${pc.connectionState}`);
          if (
            ["disconnected", "failed", "closed"].includes(pc.connectionState)
          ) {
            console.log("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Ä–∞–∑–æ—Ä–≤–∞–Ω–æ –∏–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å.");
            updateStatus(
              "–ó–≤–æ–Ω–æ–∫ –∑–∞–≤–µ—Ä—à–µ–Ω –∏–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ.",
              true
            );
            hangUp();
          }
        };

        pc.oniceconnectionstatechange = () => {
          console.log("–°–æ—Å—Ç–æ—è–Ω–∏–µ ICE —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è:", pc.iceConnectionState);
          updateStatus(`–°–æ—Å—Ç–æ—è–Ω–∏–µ ICE: ${pc.iceConnectionState}`);
        };
      }

      async function startCall() {
        const targetPeerId = peerIdInput.value.trim();
        if (!targetPeerId) return updateStatus("–í–≤–µ–¥–∏—Ç–µ ID —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞!", true);
        if (!myId)
          return updateStatus(
            "–û–∂–∏–¥–∞–π—Ç–µ –ø–æ–ª—É—á–µ–Ω–∏—è –≤–∞—à–µ–≥–æ ID –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞...",
            true
          );
        if (targetPeerId === myId)
          return updateStatus("–ù–µ–ª—å–∑—è –∑–≤–æ–Ω–∏—Ç—å —Å–∞–º–æ–º—É —Å–µ–±–µ!", true);

        if (pc && pc.connectionState !== "closed") {
          hangUp();
        }

        currentPeerId = targetPeerId;
        updateStatus(`–ù–∞—á–∏–Ω–∞–µ–º –∑–≤–æ–Ω–æ–∫ –∫ ${currentPeerId}...`);

        const stream = await getLocalStream();
        if (!stream) return;

        createPeerConnection();
        stream.getTracks().forEach((track) => pc.addTrack(track, stream));

        try {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          socket.emit("message", {
            to: currentPeerId,
            type: "offer",
            sdp: offer,
          });
          updateStatus("–û—Ç–ø—Ä–∞–≤–ª–µ–Ω –∑–∞–ø—Ä–æ—Å –Ω–∞ –∑–≤–æ–Ω–æ–∫ (offer). –û–∂–∏–¥–∞–µ–º –æ—Ç–≤–µ—Ç–∞.");
        } catch (error) {
          console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ offer:", error);
          updateStatus("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞—Ü–∏–∏ –∑–≤–æ–Ω–∫–∞.", true);
        }
      }

      async function handleOffer(msg) {
        console.log("–ü–æ–ª—É—á–µ–Ω offer:", msg);
        if (pc && pc.connectionState !== "closed") {
          hangUp();
        }

        currentPeerId = msg.from;
        peerIdInput.value = currentPeerId;
        updateStatus(`–ü–æ–ª—É—á–µ–Ω –∑–≤–æ–Ω–æ–∫ –æ—Ç ${currentPeerId}. –û—Ç–≤–µ—á–∞–µ–º...`);

        const stream = await getLocalStream();
        if (!stream) return;

        createPeerConnection();
        stream.getTracks().forEach((track) => pc.addTrack(track, stream));

        try {
          await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          socket.emit("message", {
            to: msg.from,
            type: "answer",
            sdp: answer,
          });
          updateStatus("–û—Ç–ø—Ä–∞–≤–ª–µ–Ω –æ—Ç–≤–µ—Ç –Ω–∞ –∑–≤–æ–Ω–æ–∫ (answer).");
        } catch (error) {
          console.error(
            "–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ offer –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ answer:",
            error
          );
          updateStatus("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–≤–µ—Ç–µ –Ω–∞ –∑–≤–æ–Ω–æ–∫.", true);
        }
      }

      socket.on("message", async (msg) => {
        if (!pc && msg.type !== "offer") {
          console.warn(
            "–ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ PeerConnection:",
            msg
          );
          updateStatus(
            "–ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ, –Ω–æ –∑–≤–æ–Ω–æ–∫ –µ—â–µ –Ω–µ –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞–Ω.",
            true
          );
          return;
        }

        if (msg.type === "offer") {
          await handleOffer(msg);
          return;
        }

        if (msg.type === "answer") {
          console.log("–ü–æ–ª—É—á–µ–Ω answer:", msg);
          await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
          updateStatus(
            "–ü–æ–ª—É—á–µ–Ω –æ—Ç–≤–µ—Ç –Ω–∞ –∑–≤–æ–Ω–æ–∫ (answer). –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ..."
          );
          return;
        }

        if (msg.type === "ice-candidate") {
          console.log("–ü–æ–ª—É—á–µ–Ω ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç.");
          try {
            await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
            updateStatus("–ü–æ–ª—É—á–µ–Ω –∏ –¥–æ–±–∞–≤–ª–µ–Ω ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç.");
          } catch (e) {
            console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç–∞:", e);
            updateStatus("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç–∞.", true);
          }
        }
      });

      socket.on("yourId", (id) => {
        myId = id;
        myIdEl.textContent = myId;
        console.log("–ú–æ–π ID:", myId);
        updateStatus(`–í–∞—à ID: ${myId}.`);

        const urlParams = new URLSearchParams(window.location.search);
        const joinId = urlParams.get("join");
        if (joinId && joinId !== myId) {
          peerIdInput.value = joinId;
          updateStatus(
            `ID —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞ "${joinId}" –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–ø–æ–ª–Ω–µ–Ω –∏–∑ —Å—Å—ã–ª–∫–∏.`
          );
        }
      });

      // –£–¥–∞–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π Telegram
      // socket.on("telegramIdRegistered", ...);

      socket.on("error", (msg) => {
        console.error("–û—à–∏–±–∫–∞ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞:", msg.message);
        updateStatus(`–û—à–∏–±–∫–∞ –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞: ${msg.message}`, true);
      });

      function hangUp() {
        console.log("–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∑–≤–æ–Ω–∫–∞.");
        resetCallState();
      }

      function getMyId() {
        if (myId) {
          alert("–ú–æ–π ID: " + myId);
        } else {
          alert("ID –µ—â—ë –Ω–µ –ø–æ–ª—É—á–µ–Ω. –ü–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ –∏–ª–∏ –æ–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É.");
        }
      }

      function getLink() {
        if (!myId) {
          return alert("–°–Ω–∞—á–∞–ª–∞ –¥–æ–∂–¥–∏—Ç–µ—Å—å –ø–æ–ª—É—á–µ–Ω–∏—è –≤–∞—à–µ–≥–æ ID!");
        }
        const url = new URL(window.location);
        url.searchParams.set("join", myId);
        const link = url.toString();

        navigator.clipboard
          .writeText(link)
          .then(() => alert("–°—Å—ã–ª–∫–∞ –¥–ª—è –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞:\n" + link))
          .catch(() => alert("–°—Å—ã–ª–∫–∞:\n" + link));
      }

      // –£–¥–∞–ª—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é registerTelegramId
      /*
      async function registerTelegramId() {
        if (!myId) {
          alert("–°–Ω–∞—á–∞–ª–∞ –¥–æ–∂–¥–∏—Ç–µ—Å—å –ø–æ–ª—É—á–µ–Ω–∏—è –≤–∞—à–µ–≥–æ ID –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞.");
          return;
        }
        const telegramUserId = prompt("–í–≤–µ–¥–∏—Ç–µ –≤–∞—à Telegram User ID (–º–æ–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å —á–µ—Ä–µ–∑ @userinfobot –∏–ª–∏ /mytelegramid —É –±–æ—Ç–∞):");
        if (!telegramUserId || isNaN(Number(telegramUserId))) {
          alert("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π Telegram User ID.");
          return;
        }
        telegramStatusEl.textContent = "–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è Telegram ID...";
        telegramStatusEl.style.color = "#555";
        socket.emit("message", {
          type: "registerTelegramId",
          telegramUserId: Number(telegramUserId),
        });
      }
      */

      socket.on("connect", () => {
        console.log("‚úÖ Socket.IO –ø–æ–¥–∫–ª—é—á—ë–Ω");
        updateStatus("Socket.IO –ø–æ–¥–∫–ª—é—á—ë–Ω. –û–∂–∏–¥–∞–µ–º –≤–∞—à ID...");
      });

      socket.on("disconnect", (reason) => {
        console.log(`‚ùå Socket.IO –æ—Ç–∫–ª—é—á—ë–Ω. –ü—Ä–∏—á–∏–Ω–∞: ${reason}. –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∑–≤–æ–Ω–∫–∞.`);
        updateStatus(`Socket.IO –æ—Ç–∫–ª—é—á—ë–Ω. –ü—Ä–∏—á–∏–Ω–∞: ${reason}. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É.`, true);
        hangUp();
      });

      socket.on("connect_error", (error) => {
        console.error("üö´ –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è Socket.IO:", error);
        updateStatus("–û—à–∏–±–∫–∞ Socket.IO. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ.", true);
      });

      window.onload = () => {
        const urlParams = new URLSearchParams(window.location.search);
        const joinId = urlParams.get("join");
        if (joinId) {
          peerIdInput.value = joinId;
        }
        updateStatus("–ó–∞–≥—Ä—É–∑–∫–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã. –û–∂–∏–¥–∞–Ω–∏–µ Socket.IO —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è...");
      };
    </script>
  </body>
</html>