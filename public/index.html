<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebRTC Video Call</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        text-align: center;
        background-color: #f4f4f4;
        color: #333;
        margin: 0;
        padding: 0 10px;
      }
      h2 {
        margin-top: 15px;
        font-size: 1.2em;
      }
      #controls {
        margin: 10px 0;
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
      }
      input {
        padding: 8px;
        font-size: 16px;
        border-radius: 5px;
        border: 1px solid #ccc;
        width: 150px;
      }
      button {
        padding: 10px 15px;
        font-size: 16px;
        border: none;
        border-radius: 5px;
        background-color: #007bff;
        color: white;
        cursor: pointer;
      }
      button:hover {
        background-color: #0056b3;
      }
      #statusMessage {
        margin: 10px 0;
        font-size: 1em;
        color: #555;
      }
      #videos {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
      }
      video {
        width: 45%;
        max-width: 300px;
        border: 2px solid #007bff;
        border-radius: 8px;
        background-color: black;
      }
      @media (max-width: 600px) {
        video {
          width: 90%;
        }
        input {
          width: 80%;
        }
      }
    </style>
  </head>
  <body>
    <h2>Ваш ID: <span id="myId">?</span></h2>
    <p>Собеседник: <span id="peerIdDisplay"></span></p>

    <div id="controls">
      <input id="peerIdInput" placeholder="ID собеседника" />
      <button onclick="startCall()">Позвонить</button>
      <button onclick="hangUp()">Завершить</button>
      <button onclick="getLink()">Получить ссылку</button>
    </div>

    <p id="statusMessage">Ожидание...</p>

    <div id="videos">
      <video id="localVideo" autoplay muted playsinline></video>
      <video id="remoteVideo" autoplay playsinline></video>
    </div>

    <script>
      const socket = io();
      let myId = null;
      let currentPeerId = null;
      let pc = null;
      let localStream = null;
      let remoteDescriptionSet = false;
      let pendingCandidates = [];

      const localVideo = document.getElementById("localVideo");
      const remoteVideo = document.getElementById("remoteVideo");
      const peerIdInput = document.getElementById("peerIdInput");
      const myIdEl = document.getElementById("myId");
      const peerIdDisplay = document.getElementById("peerIdDisplay");
      const statusEl = document.getElementById("statusMessage");

      function setStatus(msg, err = false) {
        statusEl.textContent = msg;
        statusEl.style.color = err ? "red" : "#333";
      }

      function setPeerDisplay(id) {
        peerIdDisplay.textContent = id || "—";
      }

      async function getLocalStream() {
        if (localStream) return localStream;
        try {
          localStream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: true,
          });
          localVideo.srcObject = localStream;
          return localStream;
        } catch (e) {
          console.error(e);
          setStatus("Ошибка доступа к камере/микрофону", true);
          return null;
        }
      }

      function createPeerConnection() {
        pc = new RTCPeerConnection({
          iceServers: [
            { urls: "stun:stun.l.google.com:19302" },
            {
              urls: "stun:stun.relay.metered.ca:80",
            },
            {
              urls: "turn:global.relay.metered.ca:80",
              username: "7b9b3d7a84f78191c4cdab15",
              credential: "gXL7OtjsO2N7Q2/k",
            },
            {
              urls: "turn:global.relay.metered.ca:80?transport=tcp",
              username: "7b9b3d7a84f78191c4cdab15",
              credential: "gXL7OtjsO2N7Q2/k",
            },
            {
              urls: "turn:global.relay.metered.ca:443",
              username: "7b9b3d7a84f78191c4cdab15",
              credential: "gXL7OtjsO2N7Q2/k",
            },
            {
              urls: "turns:global.relay.metered.ca:443?transport=tcp",
              username: "7b9b3d7a84f78191c4cdab15",
              credential: "gXL7OtjsO2N7Q2/k",
            },
          ],
        });

        pc.onicecandidate = (event) => {
          if (event.candidate && currentPeerId)
            socket.emit("message", {
              to: currentPeerId,
              type: "ice-candidate",
              candidate: event.candidate,
            });
        };

        pc.ontrack = (e) => {
          remoteVideo.srcObject = e.streams[0];
          setStatus("Удалённый поток получен!");
        };

        pc.onconnectionstatechange = () => {
          if (["failed", "disconnected", "closed"].includes(pc.connectionState))
            hangUp();
        };
      }

      async function startCall() {
        const target = peerIdInput.value.trim();
        if (!target) return setStatus("Введите ID собеседника", true);
        if (target === myId)
          return setStatus("Нельзя звонить самому себе", true);

        const stream = await getLocalStream();
        if (!stream) return;

        createPeerConnection();
        stream.getTracks().forEach((track) => pc.addTrack(track, stream));

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        currentPeerId = target;
        setPeerDisplay(currentPeerId);
        remoteDescriptionSet = false;
        pendingCandidates = [];

        socket.emit("message", { to: target, type: "offer", sdp: offer });
        setStatus("Отправлен offer, ожидаем ответ...");
      }

      async function handleOffer(msg) {
        currentPeerId = msg.from;
        setPeerDisplay(currentPeerId);

        const stream = await getLocalStream();
        if (!stream) return;

        createPeerConnection();
        stream.getTracks().forEach((track) => pc.addTrack(track, stream));

        await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
        remoteDescriptionSet = true;

        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        socket.emit("message", { to: msg.from, type: "answer", sdp: answer });
        setStatus("Ответ отправлен");

        // Применяем отложенные ICE-кандидаты
        for (const c of pendingCandidates) {
          try {
            await pc.addIceCandidate(c);
          } catch (e) {
            console.warn("Ошибка добавления отложенного ICE-кандидата:", e);
          }
        }
        pendingCandidates = [];
      }

      async function handleAnswer(msg) {
        if (!pc) return;
        await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
        remoteDescriptionSet = true;

        // Применяем отложенные ICE-кандидаты
        for (const c of pendingCandidates) {
          try {
            await pc.addIceCandidate(c);
          } catch (e) {
            console.warn("Ошибка добавления отложенного ICE-кандидата:", e);
          }
        }
        pendingCandidates = [];
        setStatus("Соединение установлено!");
      }

      async function handleIceCandidate(msg) {
        const candidate = new RTCIceCandidate(msg.candidate);
        if (remoteDescriptionSet) {
          try {
            await pc.addIceCandidate(candidate);
          } catch (e) {
            console.warn("Ошибка добавления ICE-кандидата:", e);
          }
        } else {
          pendingCandidates.push(candidate);
        }
      }

      socket.on("message", async (msg) => {
        if (msg.type === "offer") return handleOffer(msg);
        if (msg.type === "answer") return handleAnswer(msg);
        if (msg.type === "ice-candidate") return handleIceCandidate(msg);
      });

      socket.on("yourId", (id) => {
        myId = id;
        myIdEl.textContent = myId;
        setStatus(`Ваш ID: ${myId}`);
        const join = new URLSearchParams(location.search).get("join");
        if (join && join !== id) peerIdInput.value = join;
      });

      function hangUp() {
        if (pc) pc.close();
        pc = null;
        currentPeerId = null;
        remoteDescriptionSet = false;
        pendingCandidates = [];
        setPeerDisplay(null);
        remoteVideo.srcObject = null;
        setStatus("Звонок завершён");
      }

      function getLink() {
        if (!myId) return alert("ID ещё не получен!");
        const url = new URL(location);
        url.searchParams.set("join", myId);
        navigator.clipboard.writeText(url.toString());
        alert("Ссылка скопирована:\n" + url);
      }
    </script>
  </body>
</html>
